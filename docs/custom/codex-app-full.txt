1) Product mental model (what the app is)
A. Everything is a Workspace → Threads → Runs

Workspace = a repo/project context you can switch across quickly (dropdown + checkmark selection + “Add new workspace”). 

kimi-ui

Thread = a persistent “task conversation” tied to a workspace, shown in sidebar under the workspace tree and in recents. 

chat-ui

Run = a single execution of the agent (search/list/edit/etc) that produces a timeline of events + (optionally) code changes to review. 

chat-ui

B. The core differentiator: non-blocking parallelism

Runs can take minutes; user can freely jump to other threads/workspaces while a run continues. 

kimi-ui

Sidebar visually shows which threads are active/need attention (spinner/dot indicators + timestamps). 

chat-ui

This “manager vs editor” framing + parallelization is explicitly called out as the point of the product. 

codex_clone_wants

2) Global layout, navigation, and window behavior
A. Desktop window + grid

Three-column model:

Left sidebar (fixed navigation + threads)

Main content (thread timeline + summary + chat)

Optional right panel (persistent diff/review; not a modal) 

chat-ui

Sidebar is ~240px fixed. 

chat-ui

B. Top bar (main pane header)

Left side: Thread title (bold) + workspace label; overflow “…” near title. 

chat-ui

Right side: run/play control + Open ▼ + stateful action button area:

In worktree contexts: Checkout on local + Create branch here appear. 

chat-ui

In commit contexts: Commit ▼ appears. 

chat-ui

Far right: compact diffstat chip (e.g., “+718 -303”) + a “copy/duplicate/share” style icon. 

chat-ui

C. Left sidebar (information architecture)

Order and sections:

Primary nav: New thread, Automations, Skills 

chat-ui

Recents/Pinned list (title + relative time + dot indicators) 

chat-ui

“Threads” section (workspace tree with folder affordances + tiny icons like new/filter). 

chat-ui

Thread row affordances

Selected row highlight, truncated title, diffstat, relative time, and active indicator (spinner/dot). 

chat-ui

3) New Thread experience (empty state)
A. Center empty state (“Let’s build”)

Centered cloud/logo glyph + header copy (“Let’s build”). 

chat-ui

Workspace context shown under header with dropdown caret to choose workspace. 

chat-ui

B. Starter prompt cards (one-click seeds)

A row of rounded cards that fill the composer when clicked (e.g., “Create a classic snake game”, “Find and fix…”, “Summarize…$pdf”) + “Explore more” link. 

chat-ui

4) The composer (bottom input) — the app’s “control panel”
A. Input field + guidance

Large rounded rectangle composer docked at bottom. 

chat-ui

Placeholder includes operational hints: “@ to add files, / for commands”. 

kimi-ui

B. Inline control row (inside composer)

Left → right:

+ attach button 

chat-ui

(Sometimes) Agent ▼ selector appears before model selector (multi-agent profiles). 

chat-ui

Model dropdown (example: GPT-5.2-Codex) 

kimi-ui

Effort/quality dropdown (Low/Medium/High/Extra high implied; shown as “Extra high ▼”). 

kimi-ui

Lock icon (privacy/secure/context lock toggle) 

kimi-ui

Mic (voice) 

chat-ui

Send (circular button)

C. Environment row (below composer)

Segmented pill control: Local | Worktree | Cloud with filled black selected state. 

kimi-ui

Bottom-right shows git branch indicator (e.g., “main”). 

kimi-ui

D. Send/Stop + progress behavior

Send button animates by state: default/active/hover/press behaviors. 

kimi-ui

While running: send becomes a Stop control (square). 

chat-ui

Bottom-right shows a circular progress ring + percent and the active branch/worktree name. 

chat-ui

5) Thread view (core execution UX)
A. User request bubble

The initiating prompt appears as a rounded pill bubble near top-right of the content column. 

chat-ui

B. “Timeline” event list (click-through details)

Vertical list of compact events like:

“Explored 1 file, 4 searches, 1 list >”

“Edited page.tsx +3 -1 >”

Each row has a chevron, implying it opens a detail view (diff/search/list output). 

chat-ui

C. Run summary block

After timeline: prose explanation + “files touched” list + “next steps (optional)” + explicit “Tests not run (per instruction).” 

chat-ui

D. Undoable “file changed” artifact card

End of run shows a rounded card like “1 file changed” with path + diffstat and an Undo action (curved arrow). 

chat-ui

E. Sticky “Review changes →” CTA

When changes exist, above the composer:

Left: “1 file changed +77 -2”

Right: “Review changes →” opens the right-side diff panel. 

chat-ui

6) Diff / Review system (persistent right panel, not a modal)
A. Panel structure

Activating review turns UI into: center thread + right review panel. 

chat-ui

Header shows scope dropdown (e.g., “Uncommitted changes ▼”) and pills/tabs:

“Unstaged · 20”

“Staged · 1” 

chat-ui

B. File diff UX

Per-file sections with disclosure (“99 unmodified lines”), line numbers, and green/red diff styling. 

kimi-ui

Inline actions around hunks (undo/revert, plus action). 

chat-ui

C. Staging + bulk actions

Checkbox-based stage/unstage per file, plus bulk “Revert all” and “Stage all”. 

kimi-ui

D. PR review commenting inside diff

Selecting a line + “+” opens a comment box:

Title/placeholder: “Request change”

Buttons: Cancel / Comment

Comment appears as bubble; follow-up: “Address the comments”. 

kimi-ui

This is explicitly the same panel used for PR review, not only local diffs. 

chat-ui

7) Worktree mode (parallel work on same repo)
A. Entry points + mental model

User chooses Worktree in environment tabs; placeholder becomes “Ask in a parallel worktree”; branch/base selector becomes “From main ▼”. 

kimi-ui

Worktrees are positioned as the way to do multiple features simultaneously in the same project. 

codex_clone_wants

B. Worktree creation modal (terminal-like progress)

“Creating worktree” modal shows setup steps, progress bar, and terminal-like output (npm install, green checks, etc.). 

kimi-ui

Buttons: “Work locally instead” and “Cancel”. 

kimi-ui

C. Post-worktree state in top bar

New primary actions appear: Checkout on local + Create branch here. 

kimi-ui

D. Explicit “better than demo” improvement to implement

A user critique notes syncing worktree work back felt clunky; build a seamless merge/backport flow (“shadow branches” into main). 

codex_clone_wants

8) Commit + PR flow (modal-driven, guided)
A. Commit modal (“configure/confirm” = modal)

Center modal “Commit your changes” includes:

Branch name (truncated)

Change counts

“Include unstaged changes” toggle

Commit message textarea with key microcopy: “Leave blank and Codex will generate a commit message for you”

Next steps selection: Commit / Commit and push / Commit and create PR

Continue button 

kimi-ui

B. PR creation progress modal (non-blocking checklist)

After “Commit and create PR”: smaller modal “Creating a PR” with:

“Hold tight, this may take a few moments…”

Checklist: committed, pushed, creating pull request (spinner). 

chat-ui

Top toolbar also shows a subtle global “Creating PR…” state. 

chat-ui

9) Skills system (extensibility marketplace + in-thread invocation)
A. Skills screen

Title “Skills”, subtitle “Give Codex superpowers”, search bar, and New skill button. 

chat-ui

Installed + recommended sections; each skill row has icon, name, description, and scope tags like Personal/Team/System. 

kimi-ui

B. Skill detail modal (“doc + run”)

Modal includes description + numbered instructions (e.g., PR Comment Handler steps). 

chat-ui

Actions: Uninstall (destructive), Open, Try, overflow menu. 

chat-ui

C. Skill invocation in composer

Typing $ or a skill name injects a purple pill with the skill name inline with the prompt, then you continue typing. 

chat-ui

10) Automations system (“cron for code”)
A. Automations landing

Header: “Let’s automate” + subtitle “Automate work by setting up scheduled tasks”. 

chat-ui

Template grid includes items like “Find and fix a bug every morning…”, “Review PR comments every hour…”, “Update AGENTS.md every week…”, etc. 

chat-ui

B. Create automation modal

Fields:

Name

Workspaces selector (folder dropdown; selection shows a checkmark)

Prompt textarea (supports variables like $skill-creator)

Schedule tabs: Daily / Interval

Time picker + day-of-week circle toggles

Cancel / Create 

kimi-ui

C. Automation execution behavior

When an automation runs, it spawns a new thread with results ready for review (“auto-threading”). 

codex_clone_wants

11) Compact mode + always-on-top “companion” window
A. Mini mode activation + layout

Triggered by top-right collapse/expand control; main window collapses to a compact chat bubble. 

kimi-ui

Compact window shows:

Thread title, close, expand

Compact chat history

Suggested quick actions (chips) like “Remove the subtitle”

Input field 

kimi-ui

B. Always-on-top workflow

Mini window floats over a browser (e.g., localhost dev server) and you issue commands while seeing real-time changes behind it. 

kimi-ui

Controls: Close (✕), Expand (⤢), overflow/settings (⋯). 

kimi-ui

12) Integrated terminal panel (optional, but first-class)

Terminal is embedded (bottom panel), shows command + output; supports syntax highlighting, color-coded output, and auto-scroll. 

kimi-ui

13) Design system: “polished native” UI requirements
A. Typography + color tokens (baseline)

Fonts: system UI (SF Pro style); code uses mono (SF Mono/Monaco); weights 400/500/600/700. 

kimi-ui

Light palette examples:

Background #FFFFFF

Sidebar bg #F5F5F7

Primary text #1D1D1F

Secondary text #6E6E73

Link blue #007AFF

Success #34C759 / Error #FF3B30 / Warning #FF9500 

kimi-ui

B. Shape language

Everything is rounded: composer, pills, cards, modals, selection bars. (Composer is explicitly described as a large rounded rectangle; starter cards are rounded.) 

chat-ui

 

chat-ui

C. Animation + micro-interaction spec (copy this 1:1)

Modal open: scale 0.95 + fade, ~200ms ease-out

Modal close: fade ~150ms ease-in

Button hover: scale 1.02 ~150ms

Button active: scale 0.98 ~100ms

Sidebar selection: background slide ~200ms

New message: slide up + fade ~300ms

Typing indicator: bouncing dots loop ~1.4s

File expand: height + opacity ~250ms

Loading ellipsis: ~1.5s loop steps(4) 

kimi-ui

D. State indicators (be extremely consistent)

“Thinking…” with animated ellipsis

“Exploring X search, Y list”

Progress bars for setup

Percent indicators (ring + numeric)

Spinners on individual operations 

kimi-ui

14) Command surface & shortcuts (must-have UX glue)

Composer supports:

@ to add files

/ for commands menu

$ to invoke skills 

chat-ui

 

kimi-ui

Inferred keyboard shortcuts:

⌘N new thread, ⌘Enter send, Esc close modals (map to Windows equivalents). 

kimi-ui

15) Platform/build constraints you stated for your version (Windows clone)

From your notes: Rust + Tauri, using Vite + React + TanStack Router + Tailwind + shadcn/ui + TanStack Query, sharing config + chat history with the CLI, plus light mode and dark mode. 

codex_clone_wants

16) The “rules” of the UI (so it feels like the demo)

These rules are what make the product feel coherent:

Configure/confirm = modal (Commit, Create PR progress, Skill detail, Create automation). 

kimi-ui

Inspect/review = side panel (Diff/Review is persistent, not modal). 

chat-ui

Runs are narrativized (timeline events → summary → artifact card → “Review changes”). 

chat-ui

Never block the user (multitask across threads/workspaces mid-run).